# 4. 엔티티 매핑

# 객체와 테이블 매핑

## @Entity

- 클래스 앞에 붙임
    - JPA가 관리하는 엔티티
- 기본 생성자 필수
- final, enum, interface, inner 클래스에 사용 x
- name 속성
    - JPA에서 사용할 엔티티 이름 설정
        - 중복되는 다른 패키지의 클래스 있는거 아니면 그냥 기본값으로 써라

## @Table

- 디비에 저장될 테이블에 대한 정보를 설정
- 속성
    - name
    - catalog
    - schema
    - uniqueConstraints(DDL)
        - 나중에 자세히

## @SequenceGenerator

- 기본키를 지정하는 시퀀스를 지정함
    - 해당 어노테이션을 적용하지 않으면 하이버네이트의 기본 시퀀스가 만들어지고 그것을 사용함
    - 각 클래스마다 별도의 시퀀스를 사용하려면 해당 어노테이션으로 시퀀스를 설정해야 함
- 속성
    - name
        - JPA 내에서 사용하는 식별자
    - sequenceName
        - 디비에 등록되는 시퀀스 이름
    - initialValue
        - 시퀀스 시작값
    - allocationSize
        - 시퀀스 한번 호출 시 증가하는 수
        - 디비에 시퀀스 값이 하나씩 증가하도록 되어있으면 1로 설정해야 함
    - catalog & schema
        - 데이터베이스 카탈로그, 스키마 이름
- 기본키 생성 전략으로 @Table 전략을 쓰면 @TableGenerator을 사용해야 함
    - 잘 쓰진 않음

# 데이터베이스 스키마 자동 생성

- 애플리케이션 실행 시점에 DDL로 테이블을 먼저 만들어놓고 실행할 수 있음
    - `각 디비 방언에 맞는 DDL`을 사용함
- 보통 개발할 때 사용
    - 운영서버에서 사용x
        - 아니면 다듬어서 쓰거나
- persistence.xml
    - <property name=”hibernate.hbm2ddl.auto” value=”create”> 추가
    - value 옵션
        - create
        - create-drop
        - update
            - drop table하지 않고 alter table함
            - 데이터를 지울 수는 없음
        - validate
            - 엔티티와 디비의 테이블이 정상적으로 매핑되었는지 확인
        - none
            - 기능 자체를 안쓰는것
                - 주석 처리와 동일
            - 아무거나 적는것과 똑같음
                - 관례상 none으로 쓰는것
        
        > 운영 장비에서는 `절대로` create, create-drop, update를 사용하면 안됨
        > 
        
        > 테스트 서버에서도 웬만하면 쓰지말자
        > 
- DDL 생성 기능
    - @Column(unique = true, …)
    - DDL 자동 생성 시 쿼리를 추가할 수 있음
        - JPA 실행 로직에는 영향을 주지 않음

# 필드와 컬럼 매핑

- @Enumerated
    - 자바의 enum 타입 필드에 지정
        - EnumType.ORDINAL (default)
            
            > 절대 쓰지마라!
            > 
            - enum 순서를 저장 (숫자)
            - enum에 데이터가 추가되면?
                - 기존의 저장된 값은 순서가 바뀌었음에도 값이 바뀌지 않음
                - 복구할 수 없는 에러 발생!
        - EnumType.STRING
            
            > 이것만 써라!
            > 
            - enum 이름을 저장 (문자)
- @Temporal
    
    > 지금은 잘 안씀
    > 
    - Date 타입 필드에 지정
    - 자바의 Date
        - 날짜 + 시간
    - 디비
        - 날짜 (DATE)
        - 시간 (TIME)
        - 날짜 + 시간 (TIMESTAMP)
        
        → 적절한 매핑 정보를 줘야함
        
    
    > 최신 하이버네이트에서는 LocalDate(→ date), LocalDateTime(→timestamp) 타입을 지원하기 때문에 추가 어노테이션을 붙이지 않아도 됨
    > 
- @Lob
    - 디비에 큰 컨텐츠를 저장할 경우
    - 사용할 수 있는 속성이 없음
    - 필드 → clob
        - 필드가 문자인 경우
    - 필드 → blob
        - 필드가 문자가 아닌 나머지 타입인 경우
- @Transient
    - 해당 필드는 디비에 저장x
    - 애플리케이션에서 메모리로만 사용할 때 사용
- `@Column`
    - 속성
        - name
        - insertable & updateable
            - 등록, 변경 여부 설정
        - DDL 속성
            - **nullable**
                - not null 제약 조건 추가
            - unique
                - alter table로 유니크 제약 조건 추가
                    - 이렇게 추가하면 제약 조건 이름을 지정할 수 없고 이상한 이름이 지정됨
                        - 에러가 났을 때 유니크 문제인지 알 수가 없음
                    - 여기서 말고 @Table에서 uniqueConstraints 속성으로 지정
            - length
            - columnDefinition
                - 직접 정의한 정보를 DDL에 사용
            - precision
                - Bigecimal 같은 매우 큰 타입을 사용할 경우
            - scale
                - 소수점을 포함한 전체 자릿수
                - 정밀한 소수를 다뤄야 할 경우

# 기본 키 매핑

## 기본키 타입

- Long을 써야함
    - null 처리 가능
    - Integer는 10억이상 못 씀 (20억까지 아닌가? 찾아보기)
    
    > 애플리케이션 전체로 볼 때 성능에 영향을 거의 주지 않으므로 그냥 Long을 쓰자
    > 

## @Id

- 기본키 직접 할당

## @GeneratedValue

- 기본키 자동 할당
- strategy = GenerationType.~~~
    - AUTO (default)
        - 디비 방언에 맞춰 자동으로 생성
        - 디비마다 다르므로 확인해봐야 함
            - 아래 3중 하나로 설정됨
    - IDENTITY
        - 기본키 생성을 데이터베이스에 위임
        - id 값으로 null을 넣어주면 디비에서 만들어줌
            - 디비에 값이 들어가봐야 pk값을 알 수 있음
            - JPA는 pk값이 있어야 영속성 관리를 할 수 있음
                
                → 트랜잭션의 커밋까지 기다리지 않고 persist하는 순간 디비에 쿼리를 날린다.
                
    - SEQUENCE
        - 보통 오라클에서 사용
        - sequence를 만들어서 사용
        - 시퀀스 지정을 하지 않으면 하이버네이트 기본 시퀀스가 만들어지고 사용됨
            - 클래 스 앞에 @SequenceGenerator를 붙여서 클래스마다 다른 시퀀스를 사용하도록 지정할 수 있음
                - 사진
        - SEQUENCE 전략 최적화
            - 문제
                - DDL 전에 시퀀스를 만들어서 디비에 저장되어 있음
                - 만들어진 시퀀스를 애플리케이션으로 가져와서 사용해야 함
                - persist 전에 가지고 있어야 하므로 먼저 pk만 디비에서 가지고 옴
                - 이 후 엔티티의 pk를 설정한 뒤 persist 함
                - 아직 commit 전이므로 insert 쿼리는 sql 저장소에 저장된 상태
                    
                    → 그럼 디비에서 pk 가져올 때 한번 통신하고 디비에 쿼리를 날릴 때 2번 통신하게 됨 (성능 저하)
                    
            - 해결 방법
                - initalValue=1 `allocationSize=50`
                - 미리 디비에 1부터 시작해서 50씩 증가하는 시퀀스를 만들어 둠
                - 애플리케이션에서 시퀀스값을 가져옴
                    - 디비 연결하고 2번 시퀀스값을 가져옴
                        - 처음은 1을 가져옴
                        - 다음에 바로 51을 가져옴
                - 애플리케이션에서 51이 될 때까지 순차적으로 값을 사용함
                    - 1, 2, 3 …. 50 51
                - 51까지 사용하고 나면 다시 디비에서 시퀀스를 가져옴 (101)
            - 테이블 전략도 마찬가지로 미리 만들어서 올려두고 최적화함
            
            > allocationSize=1 로 두고 어떻게 호출되는지 확인해보기
            > 
    - TABLE
        - 키 생성 전용 테이블을 만들어서 사용
        - @TableGenerator을 사용해야 함
        - 장점
            - 디비마다 어떤 디비는 auto_increment를 사용하고 어떤 디비는 sequence를 사용함
            - 테이블 전략은 모든 디비에 동일하게 적용이 가능함
        - 단점
            - 성능이 떨어짐
        
        > 보통 디비 기본키 전략을 따르므로 잘 쓰진 않음
        > 

## 권장하는 식별자 전략

> Long + 대체키
> 
- 기본키 제약 조건
    1. not null
    2. unique
    3. immutable
        - 변하면 안된다!
- 자연키
    - 비지니스적으로 의미 있는 키
        
        ex) 주민등록번호, 전화번호
        
- 대체키(대리키)
    - 비지니스와 관련이 없는 키
        
        ex) 시퀀스, UUID..
        
- 자연키를 사용하는 경우 (ex. 주민번호)
    - 주민번호를 저장하고 있으면 안된다!
        - 주민번호를 사용하고 있는 모든 테이블에서 값을 삭제하고 변경해야 함
        - pk라면?
            - fk로 참조하고 있는 모든 테이블에서 변경을 해야함
                
                → 비용이 큼
                

# 실전 예제 - 요구사항 분석 & 기본 매핑